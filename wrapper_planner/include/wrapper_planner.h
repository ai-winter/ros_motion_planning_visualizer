/**
 * *********************************************************
 *
 * @file: wrapper_planner.h
 * @brief: Contains the planner ROS wrapper class
 * @author: Yang Haodong
 * @date: 2023-10-02
 * @version: 1.0
 *
 * Copyright (c) 2024, Yang Haodong. 
 * All rights reserved.
 * 
 * --------------------------------------------------------
 *
 * ********************************************************
 */
#ifndef WRAPPER_PLANNER_H
#define WRAPPER_PLANNER_H

#include <ros/ros.h>
#include <nav_core/base_global_planner.h>

#include "wrapper_planner/CallPlan.h"

#include "dynamicvoronoi.h"
#include "global_planner.h"

namespace wrapper_planner
{
class WrapperPlanner : public nav_core::BaseGlobalPlanner
{
public:
  /**
   * @brief Construct a new Wrapper Planner object
   */
  WrapperPlanner();

  /**
   * @brief Construct a new Wrapper Planner object
   * @param name        planner name
   * @param costmap_ros the cost map to use for assigning costs to trajectories
   */
  WrapperPlanner(std::string name, costmap_2d::Costmap2DROS* costmap_ros);

  /**
   * @brief Destroy the Wrapper Planner object
   */
  ~WrapperPlanner();

  /**
   * @brief Planner initialization
   * @param name       planner name
   * @param costmapRos costmap ROS wrapper
   */
  void initialize(std::string name, costmap_2d::Costmap2DROS* costmapRos);

  /**
   * @brief Planner initialization
   * @param name planner name
   */
  void initialize(std::string name);

  /**
   * @brief Plan a path given start and goal in world map
   * @param start start in world map
   * @param goal  goal in world map
   * @param plan  plan
   * @return true if find a path successfully, else false
   */
  bool makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal,
                std::vector<geometry_msgs::PoseStamped>& plan);

  /**
   * @brief Plan a path given start and goal in world map
   * @param start     start in world map
   * @param goal      goal in world map
   * @param plan      plan
   * @param tolerance error tolerance
   * @return true if find a path successfully, else false
   */
  bool makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal, double tolerance,
                std::vector<geometry_msgs::PoseStamped>& plan);

  /**
   * @brief Call planner to plan the path
   * @param req  service request, including start, goal and planner name
   * @param resp service response, including planning path and information
   * @return true if find a path successfully, else false
   */
  bool callPlanService(CallPlan::Request& req, CallPlan::Response& resp);

protected:
  /**
   * @brief Calculate plan from planning path
   * @param path path generated by global planner
   * @param plan plan transfromed from path, i.e. [start, ..., goal]
   * @return bool true if successful, else false
   */
  bool _getPlanFromPath(std::vector<Node>& path, std::vector<geometry_msgs::PoseStamped>& plan);

  /**
   * @brief Tranform from costmap(x, y) to world map(x, y)
   * @param mx costmap x
   * @param my costmap y
   * @param wx world map x
   * @param wy world map y
   */
  void _mapToWorld(double mx, double my, double& wx, double& wy);

  /**
   * @brief Tranform from world map(x, y) to costmap(x, y)
   * @param mx costmap x
   * @param my costmap y
   * @param wx world map x
   * @param wy world map y
   * @return true if successfull, else false
   */
  bool _worldToMap(double wx, double wy, double& mx, double& my);

protected:
  bool initialized_;                          // initialization flag
  costmap_2d::Costmap2D* costmap_;            // costmap
  costmap_2d::Costmap2DROS* costmap_ros_;     // costmap(ROS wrapper)
  global_planner::GlobalPlanner* g_planner_;  // global graph planner
  std::string frame_id_;                      // costmap frame ID
  unsigned int nx_, ny_;                      // costmap size
  double origin_x_, origin_y_;                // costmap origin
  double resolution_;                         // costmap resolution
  std::string planner_name_;                  // planner name
  ros::ServiceServer call_plan_srv_;          // planning service

private:
  double convert_offset_;   // offset of transform from world(x,y) to grid map(x,y)
  double tolerance_;        // tolerance
  double factor_;           // obstacle inflation factor
  bool is_outline_;         // whether outline the boudary of map
  bool is_voronoi_map_;     // whether to store Voronoi map or not
  DynamicVoronoi voronoi_;  // dynamic voronoi map
};
}  // namespace wrapper_planner

#endif